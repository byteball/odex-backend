// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	bson "github.com/globalsign/mgo/bson"

	mock "github.com/stretchr/testify/mock"

	types "github.com/byteball/odex-backend/types"
)

// OrderDao is an autogenerated mock type for the OrderDao type
type OrderDao struct {
	mock.Mock
}

// Aggregate provides a mock function with given fields: q
func (_m *OrderDao) Aggregate(q []bson.M) ([]*types.OrderData, error) {
	ret := _m.Called(q)

	var r0 []*types.OrderData
	if rf, ok := ret.Get(0).(func([]bson.M) []*types.OrderData); ok {
		r0 = rf(q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.OrderData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]bson.M) error); ok {
		r1 = rf(q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: o
func (_m *OrderDao) Create(o *types.Order) error {
	ret := _m.Called(o)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Order) error); ok {
		r0 = rf(o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: orders
func (_m *OrderDao) Delete(orders ...*types.Order) error {
	_va := make([]interface{}, len(orders))
	for _i := range orders {
		_va[_i] = orders[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...*types.Order) error); ok {
		r0 = rf(orders...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByHashes provides a mock function with given fields: hashes
func (_m *OrderDao) DeleteByHashes(hashes ...string) error {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...string) error); ok {
		r0 = rf(hashes...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Drop provides a mock function with given fields:
func (_m *OrderDao) Drop() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindAndModify provides a mock function with given fields: h, o
func (_m *OrderDao) FindAndModify(h string, o *types.Order) (*types.Order, error) {
	ret := _m.Called(h, o)

	var r0 *types.Order
	if rf, ok := ret.Get(0).(func(string, *types.Order) *types.Order); ok {
		r0 = rf(h, o)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *types.Order) error); ok {
		r1 = rf(h, o)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByHash provides a mock function with given fields: h
func (_m *OrderDao) GetByHash(h string) (*types.Order, error) {
	ret := _m.Called(h)

	var r0 *types.Order
	if rf, ok := ret.Get(0).(func(string) *types.Order); ok {
		r0 = rf(h)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(h)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByHashes provides a mock function with given fields: hashes
func (_m *OrderDao) GetByHashes(hashes []string) ([]*types.Order, error) {
	ret := _m.Called(hashes)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func([]string) []*types.Order); ok {
		r0 = rf(hashes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(hashes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByID provides a mock function with given fields: id
func (_m *OrderDao) GetByID(id bson.ObjectId) (*types.Order, error) {
	ret := _m.Called(id)

	var r0 *types.Order
	if rf, ok := ret.Get(0).(func(bson.ObjectId) *types.Order); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(bson.ObjectId) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByUserAddress provides a mock function with given fields: addr, limit
func (_m *OrderDao) GetByUserAddress(addr string, limit ...int) ([]*types.Order, error) {
	_va := make([]interface{}, len(limit))
	for _i := range limit {
		_va[_i] = limit[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, addr)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...int) []*types.Order); ok {
		r0 = rf(addr, limit...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...int) error); ok {
		r1 = rf(addr, limit...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentByUserAddress provides a mock function with given fields: a, limit
func (_m *OrderDao) GetCurrentByUserAddress(a string, limit ...int) ([]*types.Order, error) {
	_va := make([]interface{}, len(limit))
	for _i := range limit {
		_va[_i] = limit[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, a)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...int) []*types.Order); ok {
		r0 = rf(a, limit...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...int) error); ok {
		r1 = rf(a, limit...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentByUserAddressAndSignerAddress provides a mock function with given fields: address, signer
func (_m *OrderDao) GetCurrentByUserAddressAndSignerAddress(address string, signer string) ([]*types.Order, error) {
	ret := _m.Called(address, signer)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, string) []*types.Order); ok {
		r0 = rf(address, signer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(address, signer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExpiredOrders provides a mock function with given fields:
func (_m *OrderDao) GetExpiredOrders() ([]*types.Order, error) {
	ret := _m.Called()

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func() []*types.Order); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHistoryByUserAddress provides a mock function with given fields: a, limit
func (_m *OrderDao) GetHistoryByUserAddress(a string, limit ...int) ([]*types.Order, error) {
	_va := make([]interface{}, len(limit))
	for _i := range limit {
		_va[_i] = limit[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, a)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...int) []*types.Order); ok {
		r0 = rf(a, limit...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...int) error); ok {
		r1 = rf(a, limit...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMatchingBuyOrders provides a mock function with given fields: o
func (_m *OrderDao) GetMatchingBuyOrders(o *types.Order) ([]*types.Order, error) {
	ret := _m.Called(o)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(*types.Order) []*types.Order); ok {
		r0 = rf(o)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.Order) error); ok {
		r1 = rf(o)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMatchingSellOrders provides a mock function with given fields: o
func (_m *OrderDao) GetMatchingSellOrders(o *types.Order) ([]*types.Order, error) {
	ret := _m.Called(o)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(*types.Order) []*types.Order); ok {
		r0 = rf(o)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.Order) error); ok {
		r1 = rf(o)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOrderBook provides a mock function with given fields: _a0
func (_m *OrderDao) GetOrderBook(_a0 *types.Pair) ([]map[string]interface{}, []map[string]interface{}, error) {
	ret := _m.Called(_a0)

	var r0 []map[string]interface{}
	if rf, ok := ret.Get(0).(func(*types.Pair) []map[string]interface{}); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]map[string]interface{})
		}
	}

	var r1 []map[string]interface{}
	if rf, ok := ret.Get(1).(func(*types.Pair) []map[string]interface{}); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]map[string]interface{})
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*types.Pair) error); ok {
		r2 = rf(_a0)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOrderBookPrice provides a mock function with given fields: p, pp, side
func (_m *OrderDao) GetOrderBookPrice(p *types.Pair, pp float64, side string) (int64, string, error) {
	ret := _m.Called(p, pp, side)

	var r0 int64
	if rf, ok := ret.Get(0).(func(*types.Pair, float64, string) int64); ok {
		r0 = rf(p, pp, side)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(*types.Pair, float64, string) string); ok {
		r1 = rf(p, pp, side)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*types.Pair, float64, string) error); ok {
		r2 = rf(p, pp, side)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetRawOrderBook provides a mock function with given fields: _a0
func (_m *OrderDao) GetRawOrderBook(_a0 *types.Pair) ([]*types.Order, error) {
	ret := _m.Called(_a0)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(*types.Pair) []*types.Order); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.Pair) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserLockedBalance provides a mock function with given fields: account, token
func (_m *OrderDao) GetUserLockedBalance(account string, token string) (int64, []*types.Order, error) {
	ret := _m.Called(account, token)

	var r0 int64
	if rf, ok := ret.Get(0).(func(string, string) int64); ok {
		r0 = rf(account, token)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 []*types.Order
	if rf, ok := ret.Get(1).(func(string, string) []*types.Order); ok {
		r1 = rf(account, token)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*types.Order)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string) error); ok {
		r2 = rf(account, token)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Update provides a mock function with given fields: id, o
func (_m *OrderDao) Update(id bson.ObjectId, o *types.Order) error {
	ret := _m.Called(id, o)

	var r0 error
	if rf, ok := ret.Get(0).(func(bson.ObjectId, *types.Order) error); ok {
		r0 = rf(id, o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateAllByHash provides a mock function with given fields: h, o
func (_m *OrderDao) UpdateAllByHash(h string, o *types.Order) error {
	ret := _m.Called(h, o)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *types.Order) error); ok {
		r0 = rf(h, o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateByHash provides a mock function with given fields: h, o
func (_m *OrderDao) UpdateByHash(h string, o *types.Order) error {
	ret := _m.Called(h, o)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *types.Order) error); ok {
		r0 = rf(h, o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOrderFilledAmount provides a mock function with given fields: h, value
func (_m *OrderDao) UpdateOrderFilledAmount(h string, value int64) error {
	ret := _m.Called(h, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int64) error); ok {
		r0 = rf(h, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOrderFilledAmounts provides a mock function with given fields: h, values
func (_m *OrderDao) UpdateOrderFilledAmounts(h []string, values []int64) ([]*types.Order, error) {
	ret := _m.Called(h, values)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func([]string, []int64) []*types.Order); ok {
		r0 = rf(h, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string, []int64) error); ok {
		r1 = rf(h, values)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateOrderStatus provides a mock function with given fields: h, status
func (_m *OrderDao) UpdateOrderStatus(h string, status string) error {
	ret := _m.Called(h, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(h, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOrderStatusesByHashes provides a mock function with given fields: status, hashes
func (_m *OrderDao) UpdateOrderStatusesByHashes(status string, hashes ...string) ([]*types.Order, error) {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, status)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...string) []*types.Order); ok {
		r0 = rf(status, hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(status, hashes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Upsert provides a mock function with given fields: id, o
func (_m *OrderDao) Upsert(id bson.ObjectId, o *types.Order) error {
	ret := _m.Called(id, o)

	var r0 error
	if rf, ok := ret.Get(0).(func(bson.ObjectId, *types.Order) error); ok {
		r0 = rf(id, o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertByHash provides a mock function with given fields: h, o
func (_m *OrderDao) UpsertByHash(h string, o *types.Order) error {
	ret := _m.Called(h, o)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *types.Order) error); ok {
		r0 = rf(h, o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
