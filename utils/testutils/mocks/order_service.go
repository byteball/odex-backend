// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	bson "github.com/globalsign/mgo/bson"

	mock "github.com/stretchr/testify/mock"

	types "github.com/byteball/odex-backend/types"
)

// OrderService is an autogenerated mock type for the OrderService type
type OrderService struct {
	mock.Mock
}

// AdjustBalancesForUncommittedTrades provides a mock function with given fields: address, balances
func (_m *OrderService) AdjustBalancesForUncommittedTrades(address string, balances map[string]int64) map[string]int64 {
	ret := _m.Called(address, balances)

	var r0 map[string]int64
	if rf, ok := ret.Get(0).(func(string, map[string]int64) map[string]int64); ok {
		r0 = rf(address, balances)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	return r0
}

// CancelExpiredOrders provides a mock function with given fields:
func (_m *OrderService) CancelExpiredOrders() {
	_m.Called()
}

// CancelOrder provides a mock function with given fields: oc
func (_m *OrderService) CancelOrder(oc *types.OrderCancel) error {
	ret := _m.Called(oc)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.OrderCancel) error); ok {
		r0 = rf(oc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CancelOrdersSignedByRevokedSigner provides a mock function with given fields: address, signer
func (_m *OrderService) CancelOrdersSignedByRevokedSigner(address string, signer string) {
	_m.Called(address, signer)
}

// CheckIfBalancesAreSufficientAndCancel provides a mock function with given fields: address, balances
func (_m *OrderService) CheckIfBalancesAreSufficientAndCancel(address string, balances map[string]int64) {
	_m.Called(address, balances)
}

// FixOrderStatus provides a mock function with given fields: o
func (_m *OrderService) FixOrderStatus(o *types.Order) {
	_m.Called(o)
}

// GetByHash provides a mock function with given fields: h
func (_m *OrderService) GetByHash(h string) (*types.Order, error) {
	ret := _m.Called(h)

	var r0 *types.Order
	if rf, ok := ret.Get(0).(func(string) *types.Order); ok {
		r0 = rf(h)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(h)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByHashes provides a mock function with given fields: hashes
func (_m *OrderService) GetByHashes(hashes []string) ([]*types.Order, error) {
	ret := _m.Called(hashes)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func([]string) []*types.Order); ok {
		r0 = rf(hashes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(hashes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByID provides a mock function with given fields: id
func (_m *OrderService) GetByID(id bson.ObjectId) (*types.Order, error) {
	ret := _m.Called(id)

	var r0 *types.Order
	if rf, ok := ret.Get(0).(func(bson.ObjectId) *types.Order); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(bson.ObjectId) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByUserAddress provides a mock function with given fields: a, limit
func (_m *OrderService) GetByUserAddress(a string, limit ...int) ([]*types.Order, error) {
	_va := make([]interface{}, len(limit))
	for _i := range limit {
		_va[_i] = limit[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, a)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...int) []*types.Order); ok {
		r0 = rf(a, limit...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...int) error); ok {
		r1 = rf(a, limit...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentByUserAddress provides a mock function with given fields: a, limit
func (_m *OrderService) GetCurrentByUserAddress(a string, limit ...int) ([]*types.Order, error) {
	_va := make([]interface{}, len(limit))
	for _i := range limit {
		_va[_i] = limit[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, a)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...int) []*types.Order); ok {
		r0 = rf(a, limit...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...int) error); ok {
		r1 = rf(a, limit...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHistoryByUserAddress provides a mock function with given fields: a, limit
func (_m *OrderService) GetHistoryByUserAddress(a string, limit ...int) ([]*types.Order, error) {
	_va := make([]interface{}, len(limit))
	for _i := range limit {
		_va[_i] = limit[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, a)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Order
	if rf, ok := ret.Get(0).(func(string, ...int) []*types.Order); ok {
		r0 = rf(a, limit...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...int) error); ok {
		r1 = rf(a, limit...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSenderAddresses provides a mock function with given fields: oc
func (_m *OrderService) GetSenderAddresses(oc *types.OrderCancel) (string, string, error) {
	ret := _m.Called(oc)

	var r0 string
	if rf, ok := ret.Get(0).(func(*types.OrderCancel) string); ok {
		r0 = rf(oc)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(*types.OrderCancel) string); ok {
		r1 = rf(oc)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*types.OrderCancel) error); ok {
		r2 = rf(oc)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// HandleEngineResponse provides a mock function with given fields: res
func (_m *OrderService) HandleEngineResponse(res *types.EngineResponse) error {
	ret := _m.Called(res)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.EngineResponse) error); ok {
		r0 = rf(res)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewOrder provides a mock function with given fields: o
func (_m *OrderService) NewOrder(o *types.Order) error {
	ret := _m.Called(o)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Order) error); ok {
		r0 = rf(o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
